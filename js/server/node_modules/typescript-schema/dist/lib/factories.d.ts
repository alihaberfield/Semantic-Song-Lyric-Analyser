import * as m from './model';
import * as tc from './typeCloser';
export declare type TypeOrConstructableType = m.OpenType | m.ClassConstructor | m.InterfaceConstructor;
export declare type DirectOrFutureType<T extends m.ModelElement> = Promise<T> | Factory<T> | T;
export interface Context {
    typeArgs: m.Map<m.OpenType>;
    closedTypes: tc.ClosedTypes;
    closedTypeCallbacks: (() => void)[];
    isStarted: boolean;
}
export interface Factory<T extends m.ModelElement> {
    setValue(value: T): any;
    construct(): T;
}
export interface DecoratedFactory<T extends m.Decorated> extends Factory<T> {
    decorator(): DecoratorFactory<T>;
}
export interface ParameterisedTypeFactory<T extends m.ParameterisedType> extends Factory<T> {
    typeParameter(name: string): TypeParameterFactory<T>;
}
export declare abstract class AbstractFactory<M extends m.ModelElement> implements Factory<M> {
    protected _instance: M;
    protected _context: Context;
    protected _isConstructed: boolean;
    constructor(context?: Context);
    abstract setValue(m: M): any;
    construct(): M;
    protected abstract _construct(): M;
}
export declare abstract class AbstractExpressionFactory<E extends m.Expression> extends AbstractFactory<E> {
    constructor(kind: m.ExpressionKind, equals: (e: m.ModelElement) => boolean, context?: Context);
}
export declare abstract class AbstractTypeFactory<T extends m.Type> extends AbstractFactory<T> {
    constructor(kind: m.TypeKind, equals: (m: m.ModelElement) => boolean, context?: Context);
}
export declare class EnumExpressionFactory extends AbstractExpressionFactory<m.EnumExpression> {
    constructor(context?: Context);
    setValue(value: m.EnumExpression): void;
    value(value: string): void;
    enum(et: DirectOrFutureType<m.EnumType>): void;
    protected _construct(): m.EnumExpression;
}
export declare class ComplexExpressionFactory extends AbstractExpressionFactory<m.ComplexExpression> {
    constructor(context?: Context);
    setValue(value: m.ComplexExpression): void;
    protected _construct(): m.ComplexExpression;
}
export declare class ClassExpressionFactory extends AbstractExpressionFactory<m.ClassExpression> {
    constructor(context?: Context);
    setValue(value: m.ClassExpression): void;
    class(cc: DirectOrFutureType<m.ClassConstructor>): Factory<m.ClassConstructor>;
    protected _construct(): m.ClassExpression;
}
export declare class ObjectExpressionFactory extends AbstractExpressionFactory<m.ObjectExpression> {
    constructor(context?: Context);
    setValue(value: m.ObjectExpression): void;
    property<E extends AbstractExpressionFactory<any>>(key: string, kind: m.ExpressionKind): E;
    protected _construct(): m.ObjectExpression;
}
export declare class ArrayExpressionFactory extends AbstractExpressionFactory<m.ArrayExpression> {
    constructor(context?: Context);
    setValue(value: m.ArrayExpression): void;
    element<E extends AbstractExpressionFactory<any>>(kind: m.ExpressionKind): E;
    protected _construct(): m.ArrayExpression;
}
export declare class StringExpressionFactory extends AbstractExpressionFactory<m.LiteralExpression<string>> {
    constructor(context?: Context);
    setValue(value: m.LiteralExpression<string>): void;
    value(value: string): void;
    protected _construct(): m.LiteralExpression<string>;
}
export declare class BooleanExpressionFactory extends AbstractExpressionFactory<m.LiteralExpression<boolean>> {
    constructor(context?: Context);
    setValue(value: m.LiteralExpression<boolean>): void;
    value(value: boolean): void;
    protected _construct(): m.LiteralExpression<boolean>;
}
export declare class NumberExpressionFactory extends AbstractExpressionFactory<m.LiteralExpression<number>> {
    constructor(context?: Context);
    setValue(value: m.LiteralExpression<number>): void;
    value(value: number): void;
    protected _construct(): m.LiteralExpression<number>;
}
export declare class DecoratorFactory<P extends m.Decorated> extends AbstractFactory<m.Decorator<P>> {
    constructor(parent: P, context?: Context);
    decoratorType(type: DirectOrFutureType<m.TypeAlias<m.DecoratorType>>): void;
    parameter(parameter: DirectOrFutureType<m.Expression>): void;
    setValue(decorator: m.Decorator<P>): void;
    protected _construct(): m.Decorator<P>;
}
export declare class PrimitiveTypeFactory extends AbstractTypeFactory<m.PrimitiveType> {
    constructor(primitiveTypeKind: m.PrimitiveTypeKind, context?: Context);
    setValue(primitiveType: m.PrimitiveType): void;
    protected _construct(): m.PrimitiveType;
}
export declare class TupleTypeFactory extends AbstractTypeFactory<m.TupleType> {
    constructor(context?: Context);
    element(type: DirectOrFutureType<TypeOrConstructableType>): void;
    setValue(tupleType: m.TupleType): void;
    protected _construct(): m.TupleType;
}
export declare class UnionTypeFactory extends AbstractTypeFactory<m.UnionType> {
    constructor(context?: Context);
    type(type: DirectOrFutureType<TypeOrConstructableType>): void;
    setValue(unionType: m.UnionType): void;
    protected _construct(): m.UnionType;
}
export declare class EnumMemberFactory extends AbstractFactory<m.EnumMember> {
    name: string;
    constructor(parent: m.EnumType, name: string, context?: Context);
    setValue(enumMember: m.EnumMember): void;
    protected _construct(): m.EnumMember;
}
export declare class EnumTypeFactory extends AbstractTypeFactory<m.EnumType> {
    name: string;
    constructor(parent: m.TypeContainer, name: string, context?: Context);
    member(name: string): EnumMemberFactory;
    setValue(enumType: m.EnumType): void;
    protected _construct(): m.EnumType;
}
export declare class TypeQueryFactory extends AbstractTypeFactory<m.TypeQuery> {
    constructor(context?: Context);
    type(type: DirectOrFutureType<TypeOrConstructableType | m.TypeContainer | m.Value<m.TypeContainer, any>>): void;
    setValue(typeQuery: m.TypeQuery): void;
    protected _construct(): m.TypeQuery;
}
export declare class ValueFactory<P, T extends m.Type> extends AbstractFactory<m.Value<P, T>> {
    name: string;
    constructor(parent: P, name: string, valueKind: m.ValueKind, context?: Context);
    type(type: DirectOrFutureType<TypeOrConstructableType>): void;
    setValue(value: m.Value<P, T>): void;
    protected _construct(): m.Value<P, T>;
}
export declare class TypeAliasFactory<T extends m.Type> extends AbstractTypeFactory<m.TypeAlias<T>> {
    name: string;
    constructor(parent: m.TypeContainer, name: string, context?: Context);
    type(type: DirectOrFutureType<TypeOrConstructableType>): void;
    setValue(value: m.TypeAlias<T>): void;
    protected _construct(): m.TypeAlias<T>;
}
export declare abstract class AbstractParameterFactory<P extends m.Parameter> extends AbstractFactory<P> {
    name: string;
    constructor(parent: m.FunctionType, name: string, isOptional?: boolean, context?: Context);
    type(type: DirectOrFutureType<TypeOrConstructableType>): void;
    setValue(parameter: P): void;
    protected _construct(): P;
}
export declare class DecoratedParameterFactory extends AbstractParameterFactory<m.DecoratedParameter> {
    constructor(parent: m.FunctionType, name: string, isOptional?: boolean, context?: Context);
    decorator(): DecoratorFactory<m.DecoratedParameter>;
    protected _construct(): m.DecoratedParameter;
}
export declare class ParameterFactory extends AbstractParameterFactory<m.Parameter> {
}
export declare abstract class AbstractFunctionTypeFactory<F extends m.FunctionType, PC extends ParameterFactory> extends AbstractTypeFactory<F> {
    protected isDecorated: boolean;
    constructor(equals?: (m: m.ModelElement) => boolean, isDecorated?: boolean, context?: Context);
    typeParameter(name: string): TypeParameterFactory<F>;
    parameter(name: string, isOptional?: boolean): PC;
    type(type: DirectOrFutureType<TypeOrConstructableType>): void;
    setValue(f: F): void;
    protected _construct(): F;
}
export declare class DecoratedFunctionTypeFactory extends AbstractFunctionTypeFactory<m.DecoratedFunctionType, DecoratedParameterFactory> implements Factory<m.DecoratedFunctionType> {
    constructor(context?: Context);
}
export declare class FunctionTypeFactory extends AbstractFunctionTypeFactory<m.FunctionType, ParameterFactory> {
}
export declare abstract class AbstractMemberFactory<P extends m.CompositeType, M extends m.Member<any>> extends AbstractFactory<M> {
    name: string;
    constructor(parent: P, name: string, optional?: boolean, context?: Context);
    type(type: DirectOrFutureType<TypeOrConstructableType>): void;
    setValue(member: M): void;
    protected _construct(): M;
}
export declare class DecoratedMemberFactory<P> extends AbstractMemberFactory<m.DecoratedCompositeType<P>, m.DecoratedMember<P>> {
    constructor(parent: m.DecoratedCompositeType<P>, name: string, optional?: boolean, context?: Context);
    decorator(): DecoratorFactory<m.DecoratedMember<P>>;
    protected _construct(): m.DecoratedMember<P>;
}
export declare class MemberFactory extends AbstractMemberFactory<m.CompositeType, m.Member<m.CompositeType>> {
}
export declare class IndexFactory extends AbstractFactory<m.Index> {
    constructor(parent: m.CompositeType, keyType: m.PrimitiveType, context?: Context);
    valueType(type: DirectOrFutureType<TypeOrConstructableType>): void;
    setValue(index: m.Index): void;
    protected _construct(): m.Index;
}
export declare abstract class AbstractCompositeTypeFactory<C extends m.CompositeType, MC extends AbstractMemberFactory<any, any>> extends AbstractTypeFactory<C> {
    protected isDecorated: boolean;
    constructor(isDecorated?: boolean, context?: Context);
    member(name: string, optional?: boolean): MC;
    index(keyType: m.PrimitiveType): IndexFactory;
    call(call: DirectOrFutureType<m.FunctionType>): void;
    setValue(compositeType: C): void;
    protected _construct(): C;
}
export declare class DecoratedCompositeTypeFactory<P> extends AbstractCompositeTypeFactory<m.DecoratedCompositeType<P>, DecoratedMemberFactory<P>> {
    constructor(parent: P, context?: Context);
}
export declare class ContainedCompositeTypeFactory<P> extends AbstractCompositeTypeFactory<m.ContainedCompositeType<P>, MemberFactory> {
    constructor(parent: P, isDecorated?: boolean, context?: Context);
}
export declare class CompositeTypeFactory extends AbstractCompositeTypeFactory<m.CompositeType, MemberFactory> {
}
export declare class TypeParameterFactory<P extends m.ParameterisedType> extends AbstractFactory<m.TypeParameter<P>> {
    name: string;
    constructor(parent: P, name: string, context?: Context);
    extends(type: DirectOrFutureType<TypeOrConstructableType>): void;
    setValue(value: m.TypeParameter<P>): void;
    protected _construct(): m.TypeParameter<P>;
}
export declare class ClosableTypeFactory<T extends (m.Class | m.Interface), TC extends (m.ClassConstructor | m.InterfaceConstructor)> extends AbstractFactory<T> {
    protected typeConstructor: Factory<TC>;
    protected typeArguments: Factory<TypeOrConstructableType>[];
    parentConstructor(c: DirectOrFutureType<TC>): Factory<TC>;
    setValue(value: T): void;
    typeArgument(type: DirectOrFutureType<TypeOrConstructableType>): void;
    protected _construct(): T;
}
export declare class InterfaceFactory extends ClosableTypeFactory<m.Interface, m.InterfaceConstructor> {
}
export declare class ClassFactory extends ClosableTypeFactory<m.Class, m.ClassConstructor> {
}
export declare class InterfaceConstructorFactory extends AbstractFactory<m.InterfaceConstructor> {
    name: string;
    constructor(parent: m.TypeContainer, name: string, context?: Context);
    instanceType(): ContainedCompositeTypeFactory<m.InterfaceConstructor>;
    typeParameter(name: string): TypeParameterFactory<m.InterfaceConstructor>;
    extend(extend: DirectOrFutureType<m.Interface | m.InterfaceConstructor>): void;
    setValue(ic: m.InterfaceConstructor): void;
    protected _construct(): m.InterfaceConstructor;
}
export declare class ClassConstructorFactory extends AbstractFactory<m.ClassConstructor> {
    name: string;
    constructor(parent: m.TypeContainer, name: string, context?: Context);
    instanceType(): DecoratedCompositeTypeFactory<m.ClassConstructor>;
    staticType(): DecoratedCompositeTypeFactory<m.ClassConstructor>;
    typeParameter(name: string): TypeParameterFactory<m.ClassConstructor>;
    extend(extend: DirectOrFutureType<m.Class | m.ClassConstructor>): void;
    implement(extend: DirectOrFutureType<m.Interface | m.InterfaceConstructor>): void;
    decorator(): DecoratorFactory<m.ClassConstructor>;
    setValue(cc: m.ClassConstructor): void;
    protected _construct(): m.ClassConstructor;
}
export declare type TypeContainerChildType = m.ClassConstructor | m.InterfaceConstructor | m.TypeAlias<any> | m.EnumType | m.Value<m.TypeContainer, any> | m.Namespace;
export declare abstract class AbstractTypeContainerFactory<T extends m.TypeContainer> extends AbstractFactory<T> {
    protected unresolvedConstructors: m.Map<[(resolve: Factory<TypeContainerChildType>) => void, Factory<TypeContainerChildType>]>;
    protected undefinedConstructors: m.Map<Factory<TypeContainerChildType>>;
    name: string;
    constructor(kind: m.TypeContainerKind, name: string, context?: Context);
    setValue(typeContainer: m.TypeContainer): void;
    setChild(name: string, c: Factory<TypeContainerChildType>): void;
    getChild(name: string): Factory<TypeContainerChildType>;
    classConstructor(name: string): ClassConstructorFactory;
    interfaceConstructor(name: string): InterfaceConstructorFactory;
    typeAlias<T extends m.Type>(name: string): TypeAliasFactory<T>;
    enumType(name: string): EnumTypeFactory;
    static(name: string, valueKind: m.ValueKind): ValueFactory<m.TypeContainer, any>;
    namespace(name: string): NamespaceFactory;
    protected _construct(): T;
}
export declare class ModuleFactory extends AbstractTypeContainerFactory<m.Module> {
    constructor(name: string, context?: Context);
}
export declare class NamespaceFactory extends AbstractTypeContainerFactory<m.Namespace> {
    constructor(parent: m.TypeContainer, name: string, context?: Context);
}
export declare function expressionFactory<E extends m.Expression>(kind: m.ExpressionKind, context?: Context): AbstractExpressionFactory<E>;
export declare function factory<T extends m.ModelElement>(type: DirectOrFutureType<T>): Factory<T>;
