var m = require('./model');
var f = require('./factories');
function convertRawModules(openModules) {
    var modules = {};
    var moduleConstructors = {};
    var moduleNames = {};
    Object.keys(openModules).forEach(function (name) {
        moduleNames[name] = true;
    });
    var context = {
        typeArgs: {},
        closedTypes: {},
        closedTypeCallbacks: [],
        isStarted: true
    };
    var resolver = createResolver(moduleConstructors, moduleNames, context);
    Object.keys(openModules).forEach(function (name) {
        convertRawTypeContainer(name, openModules[name], resolver, context, moduleConstructors);
    });
    Object.keys(moduleConstructors).forEach(function (name) {
        modules[name] = moduleConstructors[name].construct();
    });
    context.closedTypeCallbacks.forEach(function (cb) {
        cb();
    });
    return modules;
}
exports.convertRawModules = convertRawModules;
function convertRawModule(name, openModule, modules) {
    var moduleConstructors = {};
    var moduleNames = {};
    Object.keys(modules).forEach(function (name) {
        moduleNames[name] = true;
    });
    moduleNames[name] = true;
    var context = {
        typeArgs: {},
        closedTypes: {},
        closedTypeCallbacks: [],
        isStarted: true
    };
    var resolver = createResolver(moduleConstructors, moduleNames, context);
    convertRawTypeContainer(name, openModule, resolver, context, moduleConstructors);
    Object.keys(moduleConstructors).forEach(function (name) {
        modules[name] = moduleConstructors[name].construct();
    });
    context.closedTypeCallbacks.forEach(function (cb) {
        cb();
    });
}
exports.convertRawModule = convertRawModule;
function createResolver(modules, moduleNames, context) {
    var typeCompletions = {};
    var resolver = function (reference, typeParameters) {
        if (reference.module === '@') {
            var typeParameter = typeParameters[reference.name];
            if (!typeParameter) {
                throw new Error('Cannot find type parameter: ' + reference.name);
            }
            return typeParameter;
        }
        else {
            var split = reference.module.split(':');
            var namespaces;
            var moduleName = split[0];
            var moduleFactory = modules[moduleName];
            if (moduleFactory) {
                split.shift();
                namespaces = split;
            }
            else if (moduleNames[moduleName]) {
                moduleFactory = new f.ModuleFactory(moduleName, context);
                modules[moduleName] = moduleFactory;
                split.shift();
                namespaces = split;
            }
            else {
                moduleFactory = modules[''];
                if (!moduleFactory) {
                    moduleFactory = new f.ModuleFactory('', context);
                    modules[''] = moduleFactory;
                }
                namespaces = split;
            }
            var typeContainerConstructor = moduleFactory;
            for (var i = 0; i < namespaces.length; i++) {
                typeContainerConstructor = typeContainerConstructor.namespace(namespaces[i]);
            }
            if (reference.name) {
                return typeContainerConstructor.getChild(reference.name);
            }
            else {
                return typeContainerConstructor;
            }
        }
    };
    return resolver;
}
function convertRawTypeContainer(name, rawTypeContainer, resolver, context, moduleConstructors, parent) {
    var typeContainerConstructor;
    if (parent) {
        typeContainerConstructor = parent.namespace(name);
    }
    else {
        if (!moduleConstructors[name]) {
            moduleConstructors[name] = new f.ModuleFactory(name, context);
        }
        typeContainerConstructor = moduleConstructors[name];
    }
    Object.keys(rawTypeContainer.classConstructors).forEach(function (name) {
        var classConstructor = rawTypeContainer.classConstructors[name];
        convertRawClassConstructor(name, classConstructor, resolver, context, typeContainerConstructor, {});
    });
    Object.keys(rawTypeContainer.interfaceConstructors).forEach(function (name) {
        var interfaceConstructor = rawTypeContainer.interfaceConstructors[name];
        convertRawInterfaceConstructor(name, interfaceConstructor, resolver, context, typeContainerConstructor, {});
    });
    Object.keys(rawTypeContainer.types).forEach(function (name) {
        convertTypeAlias(name, rawTypeContainer.types[name], resolver, context, typeContainerConstructor, {});
    });
    Object.keys(rawTypeContainer.namespaces).forEach(function (name) {
        convertRawTypeContainer(name, rawTypeContainer.namespaces[name], resolver, context, null, typeContainerConstructor);
    });
    Object.keys(rawTypeContainer.statics).forEach(function (name) {
        var rawStaticMember = rawTypeContainer.statics[name];
        var staticConstuctor = typeContainerConstructor.static(name, rawStaticMember.valueKind);
        if (staticConstuctor) {
            staticConstuctor.type(convertRawType(rawStaticMember.type, resolver, context, {}));
        }
    });
    Object.keys(rawTypeContainer.reexports).forEach(function (name) {
        typeContainerConstructor.setChild(name, resolver(rawTypeContainer.reexports[name], {}));
    });
}
function convertTypeAlias(name, rawTypeAlias, resolver, context, containerConstructor, typeParameters) {
    if (rawTypeAlias.typeKind === m.TypeKind.TYPE_ALIAS) {
        var rawAlias = rawTypeAlias;
        var tac = containerConstructor.typeAlias(name);
        tac.type(convertRawType(rawAlias.type, resolver, context, typeParameters));
    }
    else {
        var rawEnumType = rawTypeAlias;
        var etc = containerConstructor.enumType(name);
        rawEnumType.members.forEach(function (member) {
            etc.member(member.name);
        });
    }
}
function convertRawClassConstructor(name, rawClassConstructor, resolver, context, containerConstructor, typeParameters) {
    var ccc = containerConstructor.classConstructor(name);
    if (rawClassConstructor.typeParameters) {
        typeParameters = convertRawTypeParameters(rawClassConstructor.typeParameters, ccc, resolver, context, typeParameters);
    }
    convertRawCompositeType(rawClassConstructor.instanceType, resolver, context, typeParameters, ccc.instanceType());
    convertRawCompositeType(rawClassConstructor.staticType, resolver, context, typeParameters, ccc.staticType());
    if (rawClassConstructor.extends) {
        ccc.extend(convertRawType(rawClassConstructor.extends, resolver, context, typeParameters));
    }
    if (rawClassConstructor.implements) {
        rawClassConstructor.implements.forEach(function (extend) {
            ccc.implement(convertRawType(extend, resolver, context, typeParameters));
        });
    }
    if (rawClassConstructor.decorators) {
        convertRawDecorators(rawClassConstructor.decorators, ccc, resolver, typeParameters);
    }
}
function convertRawInterfaceConstructor(name, rawInterfaceConstructor, resolver, context, containerConstructor, typeParameters) {
    var icc = containerConstructor.interfaceConstructor(name);
    if (rawInterfaceConstructor.typeParameters) {
        typeParameters = convertRawTypeParameters(rawInterfaceConstructor.typeParameters, icc, resolver, context, typeParameters);
    }
    convertRawCompositeType(rawInterfaceConstructor.instanceType, resolver, context, typeParameters, icc.instanceType());
    if (rawInterfaceConstructor.extends) {
        rawInterfaceConstructor.extends.forEach(function (extend) {
            icc.extend(convertRawType(extend, resolver, context, typeParameters));
        });
    }
}
function convertRawTypeParameters(rawTypeParameters, parent, resolver, context, typeParameters) {
    var newTypeParameters = {};
    Object.keys(typeParameters).forEach(function (key) {
        newTypeParameters[key] = typeParameters[key];
    });
    rawTypeParameters.forEach(function (rawTypeParameter) {
        var typeParameterConstructor = parent.typeParameter(rawTypeParameter.name);
        if (rawTypeParameter.extends) {
            typeParameterConstructor.extends(convertRawType(rawTypeParameter.extends, resolver, context, typeParameters));
        }
        newTypeParameters[rawTypeParameter.name] = typeParameterConstructor;
    });
    return newTypeParameters;
}
function convertRawCompositeType(rawCompositeType, resolver, context, typeParameters, compositeTypeConstructor) {
    if (!compositeTypeConstructor) {
        compositeTypeConstructor = new f.CompositeTypeFactory(false, context);
    }
    if (rawCompositeType.index) {
        var indexConstructor = compositeTypeConstructor.index(rawCompositeType.index.keyType);
        indexConstructor.valueType(convertRawType(rawCompositeType.index.valueType, resolver, context, typeParameters));
    }
    Object.keys(rawCompositeType.members).forEach(function (name) {
        var rawMember = rawCompositeType.members[name];
        var memberConstructor = compositeTypeConstructor.member(name);
        memberConstructor.type(convertRawType(rawMember.type, resolver, context, typeParameters));
        if (rawMember.decorators) {
            convertRawDecorators(rawMember.decorators, memberConstructor, resolver, typeParameters);
        }
    });
    if (rawCompositeType.calls) {
        rawCompositeType.calls.forEach(function (call, i) {
            compositeTypeConstructor.call(convertRawType(call, resolver, context, typeParameters));
        });
    }
    return compositeTypeConstructor;
}
function convertRawType(rawType, resolver, context, typeParameters) {
    if (rawType.typeKind) {
        switch (rawType.typeKind) {
            case m.TypeKind.PRIMITIVE:
                return new f.PrimitiveTypeFactory(rawType.primitiveTypeKind, context);
            case m.TypeKind.FUNCTION:
                var rawFunctionType = rawType;
                var functionTypeConstructor = new f.DecoratedFunctionTypeFactory(context);
                if (rawFunctionType.typeParameters) {
                    typeParameters = convertRawTypeParameters(rawFunctionType.typeParameters, functionTypeConstructor, resolver, context, typeParameters);
                }
                rawFunctionType.parameters.forEach(function (parameter) {
                    var parameterConstructor = functionTypeConstructor.parameter(parameter.name, parameter.optional);
                    parameterConstructor.type(convertRawType(parameter.type, resolver, context, typeParameters));
                    if (parameter.decorators) {
                        convertRawDecorators(parameter.decorators, parameterConstructor, resolver, typeParameters);
                    }
                });
                if (rawFunctionType.type) {
                    functionTypeConstructor.type(convertRawType(rawFunctionType.type, resolver, context, typeParameters));
                }
                return functionTypeConstructor;
            case m.TypeKind.TUPLE:
                var rawTupleType = rawType;
                var tupleTypeConstructor = new f.TupleTypeFactory(context);
                rawTupleType.elements.forEach(function (element) {
                    tupleTypeConstructor.element(convertRawType(element, resolver, context, typeParameters));
                });
                return tupleTypeConstructor;
            case m.TypeKind.UNION:
                var rawUnionType = rawType;
                var unionTypeConstructor = new f.UnionTypeFactory(context);
                rawUnionType.types.forEach(function (type) {
                    unionTypeConstructor.type(convertRawType(type, resolver, context, typeParameters));
                });
                return unionTypeConstructor;
            case m.TypeKind.COMPOSITE:
                var rawCompositeType = rawType;
                return convertRawCompositeType(rawCompositeType, resolver, context, typeParameters);
            case m.TypeKind.TYPE_QUERY:
                var rawTypeQuery = rawType;
                var typeQueryConstructor = new f.TypeQueryFactory(context);
                if (rawTypeQuery.type) {
                    typeQueryConstructor.type(resolver(rawTypeQuery.type, typeParameters));
                }
                return typeQueryConstructor;
        }
    }
    else {
        if (rawType.reference) {
            var refined = rawType;
            var cc = resolver(refined.reference, typeParameters);
            var ctc = new f.ClosableTypeFactory(context);
            ctc.parentConstructor(cc);
            refined.typeArguments.forEach(function (typeArgument) {
                ctc.typeArgument(convertRawType(typeArgument, resolver, context, typeParameters));
            });
            return ctc;
        }
        else {
            return resolver(rawType, typeParameters);
        }
    }
}
function convertRawExpression(rawExpression, resolver, typeParameters) {
    var expressionConstructor = f.expressionFactory(rawExpression.expressionKind);
    switch (rawExpression.expressionKind) {
        case m.ExpressionKind.STRING:
            expressionConstructor.value(rawExpression.value);
            break;
        case m.ExpressionKind.BOOLEAN:
            expressionConstructor.value(rawExpression.value);
            break;
        case m.ExpressionKind.NUMBER:
            expressionConstructor.value(rawExpression.value);
            break;
        case m.ExpressionKind.ENUM:
            var eec = expressionConstructor;
            var ee = rawExpression;
            eec.enum(resolver(ee.enum, typeParameters));
            eec.value(ee.value);
            break;
        case m.ExpressionKind.ARRAY:
            var rawArrayExpression = rawExpression;
            rawArrayExpression.elements.forEach(function (element) {
                expressionConstructor.element(element.expressionKind).setValue(convertRawExpression(element, resolver, typeParameters));
            });
            break;
        case m.ExpressionKind.OBJECT:
            var rawObjExp = rawExpression;
            var objectExpressionConstructor = expressionConstructor;
            Object.keys(rawObjExp.properties).forEach(function (name) {
                var expression = rawObjExp.properties[name];
                objectExpressionConstructor.property(name, expression.expressionKind).setValue(expression);
            });
            break;
        case m.ExpressionKind.CLASS:
            var rawClsExp = rawExpression;
            var classExpressionConstructor = expressionConstructor;
            classExpressionConstructor.class(resolver(rawClsExp.class, typeParameters));
            break;
        case m.ExpressionKind.COMPLEX:
            break;
    }
    return expressionConstructor;
}
function convertRawDecorators(rawDecorators, parent, resolver, typeParameters) {
    rawDecorators.forEach(function (decorator) {
        var decoratorConstructor = parent.decorator();
        decoratorConstructor.decoratorType(resolver(decorator.decoratorType, typeParameters));
        if (decorator.parameters) {
            decorator.parameters.forEach(function (parameter) {
                decoratorConstructor.parameter(convertRawExpression(parameter, resolver, typeParameters));
            });
        }
    });
}
//# sourceMappingURL=rawConverter.js.map