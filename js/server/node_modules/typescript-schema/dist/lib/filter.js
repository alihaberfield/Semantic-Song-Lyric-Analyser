var m = require('./model');
function createRawTypeContainer() {
    return {
        classConstructors: {},
        interfaceConstructors: {},
        types: {},
        statics: {},
        reexports: {},
        namespaces: {}
    };
}
function filterRawModules(moduleNames, modules) {
    var filteredModules = {};
    function processTypeContainer(container) {
        Object.keys(container.classConstructors).forEach(function (clsName) {
            processClass(container.classConstructors[clsName]);
        });
        Object.keys(container.interfaceConstructors).forEach(function (intName) {
            processInterface(container.interfaceConstructors[intName]);
        });
        Object.keys(container.types).forEach(function (name) {
            processTypeAlias(container.types[name]);
        });
        Object.keys(container.namespaces).forEach(function (name) {
            processTypeContainer(container.namespaces[name]);
        });
        Object.keys(container.statics).forEach(function (name) {
            processType(container.statics[name].type);
        });
        Object.keys(container.reexports).forEach(function (name) {
            copyReference(container.reexports[name]);
        });
    }
    function processDecorator(decorator) {
        copyReference(decorator.decoratorType);
        if (decorator.parameters) {
            decorator.parameters.forEach(function (parameter) {
                processExpression(parameter);
            });
        }
    }
    function processTypeAlias(typeAlias) {
        if (typeAlias.typeKind === m.TypeKind.ENUM) {
            processType(typeAlias);
        }
        else {
            processType(typeAlias.type);
        }
    }
    function processExpression(expr) {
        switch (expr.expressionKind) {
            case m.ExpressionKind.CLASS:
                processType(expr.class);
                break;
            case m.ExpressionKind.OBJECT:
                var obj = expr;
                Object.keys(obj.properties).forEach(function (name) {
                    processExpression(obj.properties[name]);
                });
                break;
            case m.ExpressionKind.ARRAY:
                var arr = expr;
                arr.elements.forEach(function (expr) {
                    processExpression(expr);
                });
                break;
        }
    }
    function processClass(cls) {
        processType(cls.instanceType);
        processType(cls.staticType);
        if (cls.extends) {
            processType(cls.extends);
        }
        if (cls.implements) {
            cls.implements.forEach(function (type) {
                processType(type);
            });
        }
        if (cls.typeParameters) {
            cls.typeParameters.forEach(function (typeParameter) {
                if (typeParameter.extends) {
                    processType(typeParameter.extends);
                }
            });
        }
        if (cls.decorators) {
            cls.decorators.forEach(function (decorator) {
                processDecorator(decorator);
            });
        }
    }
    function processInterface(int) {
        processType(int.instanceType);
        if (int.extends) {
            int.extends.forEach(function (type) {
                processType(type);
            });
        }
        if (int.typeParameters) {
            int.typeParameters.forEach(function (typeParameter) {
                if (typeParameter.extends) {
                    processType(typeParameter.extends);
                }
            });
        }
    }
    function processType(ref) {
        if (ref.typeKind) {
            var type = ref;
            switch (type.typeKind) {
                case m.TypeKind.TYPE_QUERY:
                    if (ref.type) {
                        copyReference(ref.type);
                    }
                    break;
                case m.TypeKind.FUNCTION:
                    var f = ref;
                    f.parameters.forEach(function (parameter) {
                        if (parameter.decorators) {
                            parameter.decorators.forEach(processDecorator);
                        }
                        processType(parameter.type);
                    });
                    if (f.typeParameters) {
                        f.typeParameters.forEach(function (typeParameter) {
                            if (typeParameter.extends) {
                                processType(typeParameter.extends);
                            }
                        });
                    }
                    if (f.type) {
                        processType(f.type);
                    }
                    break;
                case m.TypeKind.TUPLE:
                    ref.elements.forEach(function (type) {
                        processType(type);
                    });
                    break;
                case m.TypeKind.UNION:
                    ref.types.forEach(function (type) {
                        processType(type);
                    });
                    break;
                case m.TypeKind.COMPOSITE:
                    var composite = ref;
                    Object.keys(composite.members).forEach(function (name) {
                        var member = composite.members[name];
                        processType(member.type);
                        if (member.decorators) {
                            member.decorators.forEach(processDecorator);
                        }
                    });
                    if (composite.index) {
                        processType(composite.index.valueType);
                    }
                    if (composite.calls) {
                        composite.calls.forEach(processType);
                    }
                    break;
            }
        }
        else if (ref.reference) {
            var rr = ref;
            copyReference(rr.reference);
            rr.typeArguments.forEach(function (typeArg) {
                processType(typeArg);
            });
        }
        else {
            copyReference(ref);
        }
    }
    function copyReference(ref) {
        var split = ref.module.split(':');
        var namespaces;
        var moduleName = split[0];
        if (split.length > 1) {
            split.shift();
            namespaces = split;
        }
        if (ref.module !== '@') {
            var refMod = modules[moduleName];
            if (!refMod) {
                refMod = modules[''].namespaces[moduleName];
            }
            var mod = refMod;
            var _mod = filteredModules[moduleName];
            if (!_mod) {
                _mod = createRawTypeContainer();
                filteredModules[moduleName] = _mod;
            }
            if (namespaces) {
                for (var i = 0; i < namespaces.length; i++) {
                    mod = mod.namespaces[namespaces[i]];
                    _mod = _mod.namespaces[namespaces[i]];
                    if (!_mod) {
                        var __mod = _mod;
                        _mod = createRawTypeContainer();
                        __mod.namespaces[namespaces[i]] = _mod;
                    }
                }
            }
            if (mod.classConstructors[ref.name]) {
                if (!_mod.classConstructors[ref.name]) {
                    _mod.classConstructors[ref.name] = mod.classConstructors[ref.name];
                    processClass(mod.classConstructors[ref.name]);
                }
            }
            else if (mod.interfaceConstructors[ref.name]) {
                if (!_mod.interfaceConstructors[ref.name]) {
                    _mod.interfaceConstructors[ref.name] = mod.interfaceConstructors[ref.name];
                    processInterface(mod.interfaceConstructors[ref.name]);
                }
            }
            else if (mod.types[ref.name]) {
                if (!_mod.types[ref.name]) {
                    _mod.types[ref.name] = mod.types[ref.name];
                    processTypeAlias(mod.types[ref.name]);
                }
            }
            else if (mod.statics[ref.name]) {
                if (!_mod.statics[ref.name]) {
                    _mod.statics[ref.name] = mod.statics[ref.name];
                    processType(mod.statics[ref.name].type);
                }
            }
            else if (mod.reexports[ref.name]) {
                if (!_mod.reexports[ref.name]) {
                    _mod.reexports[ref.name] = mod.reexports[ref.name];
                    copyReference(mod.reexports[ref.name]);
                }
            }
            else {
                throw new Error('Cannot find entity ' + ref.module + ':' + ref.name);
            }
        }
    }
    if (moduleNames.bind) {
        var f = moduleNames;
        Object.keys(modules).forEach(function (moduleName) {
            if (f(moduleName)) {
                filteredModules[moduleName] = modules[moduleName];
                processTypeContainer(modules[moduleName]);
            }
        });
    }
    else {
        moduleNames.forEach(function (moduleName) {
            filteredModules[moduleName] = modules[moduleName];
            processTypeContainer(modules[moduleName]);
        });
    }
    return filteredModules;
}
exports.filterRawModules = filterRawModules;
//# sourceMappingURL=filter.js.map