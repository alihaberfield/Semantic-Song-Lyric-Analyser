var m = require('./model');
var v = require('./modelVisitor');
var getDatabase_1 = require('../actions/databases/getDatabase');
var createDatabase_1 = require('../actions/databases/createDatabase');
var deleteDatabase_1 = require('../actions/databases/deleteDatabase');
var createDocument_1 = require('../actions/documents/createDocument');
var clearOrConfigureDatabase_1 = require('../actions/databases/clearOrConfigureDatabase');
var getForest_1 = require('../actions/forests/getForest');
var createForest_1 = require('../actions/forests/createForest');
var deleteForest_1 = require('../actions/forests/deleteForest');
var getAppServer_1 = require('../actions/appservers/getAppServer');
var createAppServer_1 = require('../actions/appservers/createAppServer');
var deleteAppServer_1 = require('../actions/appservers/deleteAppServer');
var createRuleSet_1 = require('../actions/semantics/createRuleSet');
var createTask_1 = require('../actions/tasks/createTask');
var installAlert_1 = require('../actions/alerts/installAlert');
var installServiceResourceExtension_1 = require('../actions/restapis/installServiceResourceExtension');
function deploy(client, deployer, ifExists, model) {
    var promise;
    if (model.securityDatabase) {
        promise = deployDatabase(client, deployer, ifExists, model.databases[model.securityDatabase]);
    }
    else {
        promise = Promise.resolve(true);
    }
    promise = promise.then(function (result) {
        if (result) {
            var promises = [];
            v.visitModel({
                onDatabase: function (database) {
                    if (database.name !== model.contentDatabase && database.name !== model.securityDatabase) {
                        promises.push(deployDatabase(client, deployer, ifExists, database));
                    }
                }
            }, model);
            return toPromise(promises);
        }
        else {
            return false;
        }
    });
    if (model.contentDatabase) {
        promise = promise.then(function (result) {
            if (result) {
                return deployDatabase(client, deployer, ifExists, model.databases[model.contentDatabase]);
            }
            else {
                return false;
            }
        });
    }
    return promise.then(function (result) {
        if (result) {
            var promises = [];
            v.visitModel({
                onServer: function (server) {
                    promises.push(deployer.deployServer(client, ifExists, server));
                }
            }, model);
            return toPromise(promises);
        }
        else {
            return false;
        }
    });
}
exports.deploy = deploy;
function undeploy(client, deployer, model) {
    var promises = [];
    v.visitModel({
        onServer: function (server) {
            promises.push(deployer.undeployServer(client, server));
        }
    }, model);
    return toPromise(promises).then(function (result) {
        if (result) {
            return new Promise(function (resolve, reject) {
                setTimeout(function () {
                    var promise;
                    if (model.contentDatabase) {
                        promise = undeployDatabase(client, deployer, model.databases[model.contentDatabase]);
                    }
                    else {
                        promise = Promise.resolve(true);
                    }
                    promise = promise.then(function (result) {
                        if (result) {
                            var promises_1 = [];
                            v.visitModel({
                                onDatabase: function (database) {
                                    if (database.name !== model.contentDatabase && database.name !== model.securityDatabase) {
                                        promises_1.push(undeployDatabase(client, deployer, database));
                                    }
                                }
                            }, model);
                            return toPromise(promises_1);
                        }
                        else {
                            return false;
                        }
                    });
                    if (model.securityDatabase) {
                        promise = promise.then(function (result) {
                            if (result) {
                                return undeployDatabase(client, deployer, model.databases[model.securityDatabase]);
                            }
                            else {
                                return false;
                            }
                        });
                    }
                    promise.then(resolve, reject);
                }, 5000);
            });
        }
        else {
            return false;
        }
    });
}
exports.undeploy = undeploy;
function deployAssets(adminClient, createClient, deployer, model, assetModel) {
    var promises = [];
    if (assetModel.ruleSets) {
        var schemaClient = createClient(model.schemaDatabase);
        assetModel.ruleSets.forEach(function (ruleSet) {
            promises.push(deployer.deployRuleSet(schemaClient, ruleSet));
        });
    }
    if (assetModel.modules) {
        var modulesClient = createClient(model.modulesDatabase);
        Object.keys(assetModel.modules).forEach(function (name) {
            promises.push(deployer.deployModule(modulesClient, assetModel.modules[name]));
        });
    }
    if (assetModel.extensions) {
        var modulesClient = createClient(model.modulesDatabase);
        Object.keys(assetModel.extensions).forEach(function (name) {
            promises.push(deployer.deployExtension(modulesClient, assetModel.extensions[name]));
        });
    }
    if (assetModel.tasks) {
        Object.keys(assetModel.tasks).forEach(function (name) {
            promises.push(deployer.deployTask(adminClient, assetModel.tasks[name], model));
        });
    }
    if (assetModel.alerts) {
        Object.keys(assetModel.alerts).forEach(function (name) {
            promises.push(deployer.deployAlert(adminClient, assetModel.alerts[name]));
        });
    }
    return toPromise(promises);
}
exports.deployAssets = deployAssets;
function undeployAssets(client, deployer, model) {
    var promises = [];
    v.visitModel({
        onDatabase: function (database) {
            promises.push(new Promise(function (resolve, reject) {
                client.xqueryEval('xdmp:forest-clear(xdmp:database-forests(xdmp:database("' + database.name + '")))').result(function () {
                    return true;
                }).catch(function (e) {
                    reject(e);
                    return e;
                });
            }));
        }
    }, model);
    return toPromise(promises);
}
exports.undeployAssets = undeployAssets;
function toModuleName(name) {
    name = name.replace(/\\/g, '/');
    if (name.indexOf('.js') === name.length - 3) {
        name = name.substring(0, name.length - 3);
    }
    if (name.indexOf('.sjs') !== name.length - 4) {
        name += '.sjs';
    }
    if (name.charAt(0) === '.') {
        name = name.substring(1);
    }
    if (name.charAt(0) !== '/') {
        name = '/' + name;
    }
    return name;
}
var StandardAssetDeployer = (function () {
    function StandardAssetDeployer() {
    }
    StandardAssetDeployer.prototype.deployRuleSet = function (client, spec) {
        return createRuleSet_1.createRuleSet(client, { path: spec.path }, spec.rules);
    };
    StandardAssetDeployer.prototype.undeployRuleSet = function (client, spec) {
        return null;
    };
    StandardAssetDeployer.prototype.deployModule = function (client, spec) {
        var name = toModuleName(spec.name);
        return createDocument_1.createDocument(client, { uri: toModuleName(name) }, spec.code);
    };
    StandardAssetDeployer.prototype.undeployModule = function (client, spec) {
        return null;
    };
    StandardAssetDeployer.prototype.deployExtension = function (client, spec) {
        return installServiceResourceExtension_1.installServiceResourceExtension(client, {
            name: spec.name,
            methods: {},
            description: '',
            version: '1'
        }, spec.code);
    };
    StandardAssetDeployer.prototype.undeployExtension = function (client, spec) {
        return null;
    };
    StandardAssetDeployer.prototype.deployAlert = function (client, spec) {
        var states;
        if (!spec.states) {
            states = ['create', 'modify'];
        }
        else {
            states = spec.states.map(function (state) {
                switch (state) {
                    case m.TRIGGER_STATE.CREATE:
                        return 'create';
                    case m.TRIGGER_STATE.MODIFY:
                        return 'modify';
                    case m.TRIGGER_STATE.DELETE:
                        return 'delete';
                    default:
                        throw 'Invalid alert state: ' + state;
                }
            });
        }
        var commit;
        if (!spec.commit || spec.commit === m.TRIGGER_COMMIT.PRE) {
            commit = 'pre';
        }
        else {
            commit = 'post';
        }
        return installAlert_1.installAlert(client, {
            alertUri: spec.name,
            alertName: spec.name,
            actionName: spec.name + 'Action',
            actionModule: toModuleName(spec.actionModule),
            triggerStates: states,
            triggerScope: spec.scope,
            triggerCommit: commit
        });
    };
    StandardAssetDeployer.prototype.undeployAlert = function (client, spec) {
        return null;
    };
    StandardAssetDeployer.prototype.deployTask = function (client, spec, model) {
        var type;
        switch (spec.type) {
            case m.FrequencyType.MINUTES:
                type = 'minutely';
                break;
            case m.FrequencyType.HOURS:
                type = 'hourly';
                break;
            case m.FrequencyType.DAYS:
                type = 'daily';
                break;
        }
        return createTask_1.createTask(client, {
            'task-enabled': true,
            'task-path': toModuleName(spec.module),
            'task-root': '/',
            'task-type': type,
            'task-period': spec.frequency,
            'task-database': model.contentDatabase,
            'task-modules': model.modulesDatabase,
            'task-user': spec.user
        }, 'Default');
    };
    StandardAssetDeployer.prototype.undeployTask = function (client, spec) {
        return null;
    };
    return StandardAssetDeployer;
})();
exports.StandardAssetDeployer = StandardAssetDeployer;
var StandardDeployer = (function () {
    function StandardDeployer() {
    }
    StandardDeployer.prototype.deployDatabase = function (client, ifExists, database) {
        function _createDatabase() {
            var databaseConfig = {
                'database-name': database.name,
                'triggers-database': database.triggersDatabase,
                'security-database': database.securityDatabase,
                'schema-database': database.schemaDatabase
            };
            if (database.rangeIndices) {
                databaseConfig['range-path-index'] = database.rangeIndices.map(function (rangeIndex) {
                    return {
                        'path-expression': rangeIndex.path,
                        'scalar-type': rangeIndex.scalarType,
                        collation: rangeIndex.collation || (rangeIndex.scalarType === 'string' ? 'http://marklogic.com/collation/' : ''),
                        'invalid-values': rangeIndex.invalidValues || 'reject',
                        'range-value-positions': rangeIndex.rangeValuePositions || false
                    };
                });
            }
            if (database.geoIndices) {
                databaseConfig['geospatial-path-index'] = database.geoIndices.map(function (geoIndex) {
                    return {
                        'path-expression': geoIndex.path,
                        'coordinate-system': geoIndex.coordinateSystem || 'wgs84',
                        'point-format': geoIndex.pointFormat,
                        'invalid-values': geoIndex.invalidValues || 'reject',
                        'range-value-positions': geoIndex.rangeValuePositions || false
                    };
                });
            }
            if (database.triples) {
                databaseConfig['triple-index'] = true;
                databaseConfig['collection-lexicon'] = true;
            }
            if (database.defaultRulesets) {
                databaseConfig['default-ruleset'] = database.defaultRulesets.map(function (ruleSet) {
                    return { location: ruleSet };
                });
            }
            return createDatabase_1.createDatabase(client, databaseConfig).then(function () {
                return true;
            });
        }
        var undeploy = this.undeployDatabase;
        var clear = this.cleanDatabase;
        return getDatabase_1.getDatabase(client, database.name).then(function () {
            switch (ifExists) {
                case m.IF_EXISTS.recreate:
                    return undeploy(client, database).then(_createDatabase);
                case m.IF_EXISTS.clear:
                    return clear(client, database);
                case m.IF_EXISTS.ignore:
                    return false;
                case m.IF_EXISTS.fail:
                    throw "Database " + database.name + " already exists";
            }
        }, _createDatabase);
    };
    StandardDeployer.prototype.cleanDatabase = function (client, database) {
        return clearOrConfigureDatabase_1.clearOrConfigureDatabase(client, database.name, new clearOrConfigureDatabase_1.ClearDatabaseOperation());
    };
    StandardDeployer.prototype.undeployDatabase = function (client, database) {
        return deleteDatabase_1.deleteDatabase(client, database.name).then(function () {
            return true;
        });
    };
    StandardDeployer.prototype.deployForest = function (client, ifExists, forest) {
        function _createForest() {
            return createForest_1.createForest(client, {
                'forest-name': forest.name,
                host: forest.host,
                database: forest.database
            }).then(function () {
                return true;
            });
        }
        var undeploy = this.undeployForest;
        return getForest_1.getForest(client, forest.name).then(function () {
            switch (ifExists) {
                case m.IF_EXISTS.recreate:
                case m.IF_EXISTS.clear:
                    return undeploy(client, forest).then(_createForest);
                case m.IF_EXISTS.ignore:
                    return false;
                case m.IF_EXISTS.fail:
                    throw "Forest " + forest.name + " already exists";
            }
        }, _createForest);
    };
    StandardDeployer.prototype.undeployForest = function (client, forest) {
        return deleteForest_1.deleteForest(client, forest.name).then(function () {
            return true;
        });
    };
    StandardDeployer.prototype.deployServer = function (client, ifExists, server) {
        function _createServer() {
            return createAppServer_1.createAppServer(client, {
                'server-name': server.name,
                'server-type': 'http',
                root: '/',
                port: server.port,
                'content-database': server.contentDatabase,
                'modules-database': server.modulesDatabase,
                'group-name': server.group,
                'log-errors': true,
                'default-error-format': 'json',
                'error-handler': '/MarkLogic/rest-api/error-handler.xqy',
                'url-rewriter': '/MarkLogic/rest-api/rewriter.xml',
                'rewrite-resolves-globally': true
            }).then(function () {
                return true;
            });
        }
        var undeploy = this.undeployServer;
        return getAppServer_1.getAppServer(client, server.name).then(function () {
            switch (ifExists) {
                case m.IF_EXISTS.recreate:
                case m.IF_EXISTS.clear:
                    return undeploy(client, server).then(_createServer);
                case m.IF_EXISTS.ignore:
                    return false;
                case m.IF_EXISTS.fail:
                    throw "Server " + server.name + " already exists";
            }
        }, _createServer);
    };
    StandardDeployer.prototype.undeployServer = function (client, server) {
        return deleteAppServer_1.deleteAppServer(client, server.name, server.group).then(function () {
            return true;
        });
    };
    return StandardDeployer;
})();
exports.StandardDeployer = StandardDeployer;
function toPromise(promises) {
    return Promise.all(promises).then(function (results) {
        for (var i = 0; i < results.length; i++) {
            if (!results[i]) {
                return false;
            }
        }
        return true;
    });
}
function deployDatabase(client, deployer, ifExists, database) {
    return deployer.deployDatabase(client, ifExists, database).then(function () {
        var promises = [];
        database.forests.forEach(function (forest) {
            promises.push(deployer.deployForest(client, ifExists, forest));
        });
        return toPromise(promises);
    });
}
function undeployDatabase(client, deployer, database) {
    return deployer.undeployDatabase(client, database).then(function (result) {
        if (result) {
            var promises = [];
            database.forests.forEach(function (forest) {
                promises.push(deployer.undeployForest(client, forest));
            });
            return toPromise(promises);
        }
        else {
            return false;
        }
    });
}
//# sourceMappingURL=deployer.js.map